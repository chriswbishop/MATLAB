function portaudio_adaptiveplay(X, varargin)
%% DESCRIPTION:
%
%   This function is designed to allow (near) real-time modification of
%   sound playback. To do this, the function will accept a function handle
%   to a "checker" function that determins whether or not a change in the
%   audio is required. The function will also accept a "modifier" function
%   that modifies the time series during sound playback. 
%
%   This function (the top-level function) will then handle the transition
%   from one sound state to the next. 
%
% INPUT:
%
%   X:  
%
% Parameters:
%
%   'bock_dur':     data block size in seconds. The shorter it is, the
%                   faster the adaptive loop is. The longer it is, the less
%                   likely you are to run into buffering problems. 
%
%   'modcheck': function handle. This class of functions determines whether
%               or not a modification is necessary. At the time he wrote
%               this, CWB could imagine circumstances in which the same
%               modifier must be applied, but under various conditions. By
%               separating the functionality of 'modcheck' and 'modifier',
%               the user can create any combination. This should, in
%               theory, improve the versatility of the adaptive playback
%               system. 
%
%               'modcheck' can perform any type of check, but must be self
%               contained. Meaning, it (typically) cannot rely exclusively
%               on information present in the adaptive play control loop.
%               An example of a modcheck might go something like this.
%
%                   1. On the first call, create a keyboard queue to
%                   monitor for specific button presses.
%
%                   2. On subsequent calls, check the queue and determine
%                   if a specific button (or combination thereof) was
%                   pressed.
%
%                   3. If some preexisting conditions are met, then modify
%                   the signal. Otherwise, do not modify the signal.
%
%               Alternatively, a modcheck might do the following.
%
%                   1. On the first call, open a GUI with callback buttons
%                   for users to click on. 
%
%                   2. On successive calls, check to see if a button has
%                   been clicked. If it has, then return a modification
%                   code.
%
%               'modchecks' must accept a single input; a structure with
%               whatever information successive calls to the modcheck will
%               need (e.g., figure handles, etc.). 
%
%               modchecks must return the following variables
%                   
%                   1. needmod: bool, determines whether or not a
%                   modification is necessary at all.
%           
%                   2. mod_code:    integer (typically) describing the
%                                   nature of the required modification.
%                                   This code is further interpreted by
%                                   the modifier (below).
%
%                   3. c:   a structure containing additional information
%                           that may be necessary for successive calls to
%                           'modcheck'.
%
%   'modifier': function handle. This class of functions will modify the
%               output signal X when the conditions of 'modcheck' (see
%               above) are satisfied. The function can do just about
%               anything, but must conform to some general guidelines.
%
%                   1. The function must accept three inputs
%
%                           X:  the time series to alter
%
%                           mod_code:   a modification code. This will
%                                       prove useful when one of several
%                                       conditional modifications are
%                                       possible (e.g., making a sound
%                                       louder or quieter). 
%
%                           m:  a structure with other information
%                               generated by a previous call to the
%                               modifier.
%
%                   2. The function must have three outputs
%
%                           Y:  the modified time series X
%
%                           m:  the updated modifier structure. This will
%                               be provided as an input during all
%                               subsequent calls to the modifier.
%
%                           term:   bool, whether or not to termination the
%                                   adaptive playback. (true = terminate |
%                                   false = continue playback)
%
%
% OUTPUT:
%
%   XXX
%
% Development:
%
%   1. Add timing checks to make sure we have enough time to do everything
%   we need before the buffer runs out
%
%   2. Additional windowing parameters and defaults. For windowing, use a
%   Hanning window by default. 5 ms should be fine, but allow user to
%   specify duration of windowing in the event that popping occurs.
%
%   3. Add options for handling buffer underruns. These should generally
%   throw an irrecoverable error lest our acoustic control deteriorate, but
%   there may be circumstances in which the user wants to ignore these
%   warnings and move despite any potential problems. 
%
%   4. Add continuously looped playback (priority 1). 
%
%   5. Handle sound initiation better. Typically buffer position is not
%   well controlled during playback of first block - meaning the buffer
%   might be in the middle of the segment by chance and thus some of the
%   signal is cut out.
%
%   6. Handle signal termination better. Need to zero out the buffer, then
%   stop the portaudio handle. CWB struggling with doing this cleanly at
%   the moment. He'll come back to it later. 
%
%   7. Simple clipping check (signal cannot exceed -1 or 1)
%
% Christopher W. Bishop
%   University of Washington
%   5/14

%% MASSAGE INPUT ARGS
% Convert inputs to structure
%   Users may also pass a parameter structure directly, which makes CWB's
%   life a lot easier. 
if length(varargin)>1
    p=struct(varargin{:}); 
elseif length(varargin)==1
    p=varargin{1};
elseif isempty(varargin)
    p=struct();     
end %

%% INPUT CHECK AND DEFAULTS
%   Load defaults from SIN_defaults, then overwrite these by user specific
%   inputs. 
defs=SIN_defaults; 
d=defs.anl; 
FS=d.fs; 
% FS=22050; 

% OVERWRITE DEFAULTS
%   Overwrite defaults if user specifies something different.
flds=fieldnames(p);
for i=1:length(flds)
    d.(flds{i})=p.(flds{i}); 
end % i=1:length(flds)

% Clear p
%   Only want to use d for consistency and to minimize errors. So clear 'p'
%   to remove temptation.
clear p; 

%% INTIALIZE MODCHECK AND MODIFIER STRUCTS
m=struct(); % modifier struct
c=struct(); % modcheck struct

%% LOAD DATA
%   Load X. Support WAV and double format, multi-channel OK
%   (infinite).
t.datatype=[1 2];
if isfield(d, 'fsx') && ~isempty(d.fsx), t.fs=d.fsx; end 
[X, fsx]=AA_loaddata(X, t); 

% Playback channel check
%   Confirm that the number of playback channels corresponds to the number
%   of columns of X and Y. 
if numel(d.playback_channels) ~= size(X,2)
    error('Incorrect number of playback channels specified'); 
end % if numel(p.playback_channels) ...

%% MATCH SAMPLING RATE
%   Resample playback sounds so they match the playback sampling rate.
X=resample(X, FS, fsx); 

%% LOAD PLAYBACK AND RECORDING DEVICES
%   Get these from SIN_defaults as well. 
InitializePsychSound; 

%% CREATE BUFFER
% Create empty playback buffer
buffer_nsamps=round(d.block_dur*FS)*2; % need 2 x the buffer duration

% Find buffer locations
buffer_ind=[1 buffer_nsamps/2+1];

%% OPEN PLAYbACK DEVICE
% Continuous playback
[pstruct]=portaudio_GetDevice(defs.playback.device);
phand = PsychPortAudio('Open', pstruct.DeviceIndex, 1, 0, FS, pstruct.NrOutputChannels); 

%% FILL X TO MATCH NUMBER OF CHANNELS
x=zeros(size(X,1), pstruct.NrOutputChannels);
x(:, d.playback_channels)=X; % copy data over into playback channels
X=x; % reassign X

% Clear temporary variable x 
clear x; 

%% CREATE WINDOWING FUNCTION (ramp on/off)
%   For ease, let's use a Hanning window for now (makes implementation more
%   straightforward). 
win=window(@hann, round(0.005*2*FS)); % Create 5 ms onset/offset ramp

% Match number of channels
win=win*ones(1, size(X,2)); 

% Break up by ramp_on and ramp_off (saves time in playback)
ramp_on=win(1:length(win)/2,:); ramp_on=[ramp_on; ones(buffer_nsamps/2 - size(ramp_on,1), size(ramp_on,2))];
ramp_off=win(length(win)/2:end,:); ramp_off=[ramp_off; zeros(buffer_nsamps/2 - size(ramp_off,1), size(ramp_off,2))];

% nblocks
nblocks=ceil(size(X,1)./size(ramp_on,1)); 

for i=1:nblocks
    tic
    % Which buffer block are we filling?
    %   Find start and end of the block
    startofblock=buffer_ind(1+mod(i-1,2));
    
    % Find data we want to load 
    if i==nblocks
        % Load with the remainder of X, then pad zeros.         
        data=[X(1+buffer_nsamps/2*(i-1):end, :); zeros(buffer_nsamps/2 - size(X(1+buffer_nsamps/2*(i-1):end, :),1), size(X,2))];
    else
        data=X(1+buffer_nsamps/2*(i-1):(buffer_nsamps/2)*i,:);
    end 
    
    % Check if modification necessary
    [mod_code, c]=d.modcheck.fhandle(c); 
    
    % Save upcoming data
    x=data.*ramp_off;
        
    % Modify main data stream
    [X, m]=d.modifier.fhandle(X, mod_code, m); 
        
    % Grab data from modified signal
    if i==nblocks
        % Load with the remainder of X, then pad zeros.         
        data=[X(1+buffer_nsamps/2*(i-1):end, :); zeros(buffer_nsamps/2 - size(X(1+buffer_nsamps/2*(i-1):end, :),1), size(X,2))];
    else
        data=X(1+buffer_nsamps/2*(i-1):(buffer_nsamps/2)*i,:);
    end % if 
        
    % Ramp new stream up, mix with old stream. 
    %   The mixed signal is what's played back. 
    
    % XXX SHOULD THIS BE MIXED DIFFERENTLY FOR THE FIRST DATA BLOCK XXX ???
    data=data.*ramp_on + x; 
    
    % First time through, we need to start playback
    if i==1
        % Start audio playback, but do not advance until the device has really
        % started. Should help compensate for intialization time. 
        
        % Fill buffer with zeros
        PsychPortAudio('FillBuffer', phand, zeros(buffer_nsamps,size(data,2))'); 
        
        % Infinite repetitions
        %   Don't wait for it to start, just start moving along
        PsychPortAudio('Start', phand, 0, [], 0);
        
    end % if i==1
    
    % Now, loop until we're half way through the samples in this particular
    % buffer block
    pstatus=PsychPortAudio('GetStatus', phand);
    
    % Load data into playback buffer
    %   CWB tried specifying the start location (last parameter), but he
    %   encountered countless buffer underrun errors. Replacing the start
    %   location with [] forces the data to be "appended" to the end of the
    %   buffer. For whatever reason, this is far more robust and CWB
    %   encountered 0 buffer underrun errors. 
    PsychPortAudio('FillBuffer', phand, data', 1, []);    
    toc
    
    % Wait for previous section to finish before rewriting the audio 
    while pstatus.ElapsedOutSamples < buffer_nsamps/2 * (i-1), pstatus=PsychPortAudio('GetStatus', phand); end
    
    pstatus=PsychPortAudio('GetStatus', phand);
    % Each time we're half way through a block, start rewriting the buffer
    while mod(pstatus.ElapsedOutSamples, buffer_nsamps) - startofblock < buffer_nsamps/4 % start updating sooner.  
        pstatus=PsychPortAudio('GetStatus', phand); 
    end % while
    
end % for i=1:nblocks

% Clumsy close
%   Needs to be smarter to guarantee that sound playback has stopped. See
%   development notes above. 
PsychPortAudio('Close')