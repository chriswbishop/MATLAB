function portaudio_adaptiveplay(X, varargin)
%% DESCRIPTION:
%
%   This function is designed to allow (near) real-time modification of
%   sound playback. To do this, the function will accept a function handle
%   to a "checker" function that determins whether or not a change in the
%   audio is required. The function will also accept a "modifier" function
%   that modifies the time series during sound playback. 
%
%   This function (the top-level function) will then handle the transition
%   from one sound state to the next. 
%
% INPUT:
%
%   X:  
%
% Parameters:
%
%   'bock_dur':     data block size in seconds. The shorter it is, the
%                   faster the adaptive loop is. The longer it is, the less
%                   likely you are to run into buffering problems. 
%
%   'modcheck': function handle. This class of functions determines whether
%               or not a modification is necessary. At the time he wrote
%               this, CWB could imagine circumstances in which the same
%               modifier must be applied, but under various conditions. By
%               separating the functionality of 'modcheck' and 'modifier',
%               the user can create any combination. This should, in
%               theory, improve the versatility of the adaptive playback
%               system. 
%
%               'modcheck' can perform any type of check, but must be self
%               contained. Meaning, it (typically) cannot rely exclusively
%               on information present in the adaptive play control loop.
%               An example of a modcheck might go something like this.
%
%                   1. On the first call, create a keyboard queue to
%                   monitor for specific button presses.
%
%                   2. On subsequent calls, check the queue and determine
%                   if a specific button (or combination thereof) was
%                   pressed.
%
%                   3. If some preexisting conditions are met, then modify
%                   the signal. Otherwise, do not modify the signal.
%
%               Alternatively, a modcheck might do the following.
%
%                   1. On the first call, open a GUI with callback buttons
%                   for users to click on. 
%
%                   2. On successive calls, check to see if a button has
%                   been clicked. If it has, then return a modification
%                   code.
%
%               'modchecks' must accept a single input; a structure with
%               whatever information successive calls to the modcheck will
%               need (e.g., figure handles, etc.). 
%
%               modchecks must return the following variables
%                   
%                   1. needmod: bool, determines whether or not a
%                   modification is necessary at all.
%           
%                   2. mod_code:    integer (typically) describing the
%                                   nature of the required modification.
%                                   This code is further interpreted by
%                                   the modifier (below).
%
%                   3. c:   a structure containing additional information
%                           that may be necessary for successive calls to
%                           'modcheck'.
%
%   'modifier': function handle. This class of functions will modify the
%               output signal X when the conditions of 'modcheck' (see
%               above) are satisfied. The function can do just about
%               anything, but must conform to some general guidelines.
%
%                   1. The function must accept three inputs
%
%                           X:  the time series to alter
%
%                           mod_code:   a modification code. This will
%                                       prove useful when one of several
%                                       conditional modifications are
%                                       possible (e.g., making a sound
%                                       louder or quieter). 
%
%                           m:  a structure with other information
%                               generated by a previous call to the
%                               modifier.
%
%                   2. The function must have three outputs
%
%                           Y:  the modified time series X
%
%                           m:  the updated modifier structure. This will
%                               be provided as an input during all
%                               subsequent calls to the modifier.
%
%                           term:   bool, whether or not to termination the
%                                   adaptive playback. (true = terminate |
%                                   false = continue playback)
%
%   'adaptive_mode':    string, describing how the modifications should be
%                       applied to the data stream. This is still under
%                       development, but different tests (e.g., HINT and
%                       ANL) need the modifications to occur on different
%                       timescales (between words or during a continuous
%                       playback stream). The hope here is to include
%                       various adaptive modes to accomodate these needs.
%
%                           'realtime': apply modifications in as close to
%                                       real time as possible. This will
%                                       depend heavily on the size on the
%                                       'block_dur' parameter above; the
%                                       longer the block_dur, the longer it
%                                       takes for the "real time" changes
%                                       to take effect. But if the
%                                       block_dur is too short, then you
%                                       run into other, irrecoverable
%                                       problems (like buffer underruns).
%                                       Choose your poison. 
%
%                           'byseries':    apply modifications at the end 
%                                           of each playback file. (under
%                                           development). This mode was
%                                           intended to accomodate the 
%                                           HINT.       
%
% Windowing options (for 'realtime' playback):
%
%   In 'realtime' mode, data are frequently ramped off or on (that is, fade
%   out or fade in) to create seamless transitions. These paramters allow
%   the user to specify windowing options, including a windowing function
%   (provided it's supported by matlab's "window" function) and a ramp
%   time.
%
%       'window_fhandle':function handle to windowing function. (default =
%                       @hann). See window.m for more options. 
%
%       'window_dur':   duration of windowing function. Too short may lead
%                       to popping or clicking in playback. Too long and
%                       it takes longer for adpative changes to occur
%                       (longer before the change "fades in"). 
%                       (seconds | default = 0.005 (5 msec))
%
% OUTPUT:
%
%   XXX
%
% Development:
%
%   1. Add timing checks to make sure we have enough time to do everything
%   we need before the buffer runs out
%
%   2. Additional windowing parameters and defaults. For windowing, use a
%   Hanning window by default. 5 ms should be fine, but allow user to
%   specify duration of windowing in the event that popping occurs.
%
%   3. Add options for handling buffer underruns. These should generally
%   throw an irrecoverable error lest our acoustic control deteriorate, but
%   there may be circumstances in which the user wants to ignore these
%   warnings and move despite any potential problems. 
%
%   4. Add continuously looped playback (priority 1). 
%
%   5. Handle sound initiation better. Typically buffer position is not
%   well controlled during playback of first block - meaning the buffer
%   might be in the middle of the segment by chance and thus some of the
%   signal is cut out.
%
%   6. Handle signal termination better. Need to zero out the buffer, then
%   stop the portaudio handle. CWB struggling with doing this cleanly at
%   the moment. He'll come back to it later. 
%
%   7. Simple clipping check (signal cannot exceed -1 or 1)
%
%   8. Load defaults in a smarter way. Right now hard-coded to load ANL
%   parameters, but CWB has plans to use this for HINT and other tests.
%
%   9. Add "concatenate" to allow user to concatenate several time series.
%   (e.g., concatenate multiple data files into a single data stream). 
%
%   10. Add ability to independently control multiple channels (e.g.,
%   adaptive changes for each channel separately). Or, alternatively, allow
%   user to select which channels to apply adaptive changes to rather than
%   the whole time series and all channels wholesale. Might be worth adding
%   this to the modifier function ... not sure. Needs more thought. 
%
% Christopher W. Bishop
%   University of Washington
%   5/14

%% MASSAGE INPUT ARGS
% Convert inputs to structure
%   Users may also pass a parameter structure directly, which makes CWB's
%   life a lot easier. 
if length(varargin)>1
    p=struct(varargin{:}); 
elseif length(varargin)==1
    p=varargin{1};
elseif isempty(varargin)
    p=struct();     
end %

%% INPUT CHECK AND DEFAULTS
%   Load defaults from SIN_defaults, then overwrite these by user specific
%   inputs. 
defs=SIN_defaults; 
d=defs.anl; 
FS=d.fs; 
% FS=22050; 

%% FUNCTION SPECIFIC DEFAULTS
%   - Use a Hanning windowing function by default
%   - Use 5 ms ramp time
if ~isfield(d, 'window_fhandle') || isempty(d.window_fhandle), d.window_fhandle=@hann; end
if ~isfield(d, 'window_dur') || isempty(d.window_dur), d.window_dur=0.005; end 

% OVERWRITE DEFAULTS
%   Overwrite defaults if user specifies something different.
flds=fieldnames(p);
for i=1:length(flds)
    d.(flds{i})=p.(flds{i}); 
end % i=1:length(flds)

% Clear p
%   Only want to use d for consistency and to minimize errors. So clear 'p'
%   to remove temptation.
clear p; 

%% INTIALIZE MODCHECK AND MODIFIER STRUCTS
m=struct(); % modifier struct
c=struct(); % modcheck struct

%% LOAD DATA
%   Load X. Support WAV and double format, multi-channel OK
%   (infinite).
t.datatype=[1 2];
if isfield(d, 'fsx') && ~isempty(d.fsx), t.fs=d.fsx; end 
[X, fsx]=AA_loaddata(X, t); 

% Playback channel check
%   Confirm that the number of playback channels corresponds to the number
%   of columns of X and Y. 
if numel(d.playback_channels) ~= size(X,2)
    error('Incorrect number of playback channels specified'); 
end % if numel(p.playback_channels) ...

%% MATCH SAMPLING RATE
%   Resample playback sounds so they match the playback sampling rate.
X=resample(X, FS, fsx); 

%% LOAD PLAYBACK AND RECORDING DEVICES
%   Get these from SIN_defaults as well. 
InitializePsychSound; 

%% CREATE BUFFER
% Create empty playback buffer
buffer_nsamps=round(d.block_dur*FS)*2; % need 2 x the buffer duration

% block_nsamps
%   This prooved useful in the indexing below. CWB opted to use a two block
%   buffer for playback because it's the easiest to code and work with at
%   the moment. 
block_nsamps=buffer_nsamps/2; 

% Find beginning of each "block" within the buffer
block_start=[1 block_nsamps+1];

%% OPEN PLAYbACK DEVICE
% Continuous playback
[pstruct]=portaudio_GetDevice(defs.playback.device);
phand = PsychPortAudio('Open', pstruct.DeviceIndex, 1, 0, FS, pstruct.NrOutputChannels); 

%% FILL X TO MATCH NUMBER OF CHANNELS
x=zeros(size(X,1), pstruct.NrOutputChannels);
x(:, d.playback_channels)=X; % copy data over into playback channels
X=x; % reassign X

% Clear temporary variable x 
clear x; 

%% CREATE WINDOWING FUNCTION (ramp on/off)
%   For ease, let's use a Hanning window for now (makes implementation more
%   straightforward). 
win=window(d.window_fhandle, round(d.window_dur*2*FS)); % Create onset/offset ramp

% Match number of channels
win=win*ones(1, size(X,2)); 

% Break up by ramp_on and ramp_off (saves time in playback)
ramp_on=win(1:length(win)/2,:); ramp_on=[ramp_on; ones(block_nsamps - size(ramp_on,1), size(ramp_on,2))];
ramp_off=win(length(win)/2:end,:); ramp_off=[ramp_off; zeros(block_nsamps - size(ramp_off,1), size(ramp_off,2))];

% nblocks
%   Number of blocks necessary to present the stimulus from start to finish 
%   ONCE.
nblocks=ceil(size(X,1)./size(ramp_on,1)); 

%% INITIALIZE MODIFICATION CHECK AND MOFIFIER
%   These functions often have substantial overhead on their first call, so
%   they need to be primed (e.g., if a figure must be generated or a sound
%   device initialized).

% Call modcheck
[mod_code, c]=d.modcheck.fhandle(c); 
        
% Modify all time series        
[X, m]=d.modifier.fhandle(X, mod_code, m); 

switch lower(d.adaptive_mode)
    case {'realtime'}
        for i=1:nblocks
            tic
            % Which buffer block are we filling?
            %   Find start and end of the block
            startofblock=block_start(1+mod(i-1,2));
    
            % Find data we want to load 
            if i==nblocks
                % Load with the remainder of X, then pad zeros.         
                data=[X(1+block_nsamps*(i-1):end, :); zeros(block_nsamps - size(X(1+block_nsamps*(i-1):end, :),1), size(X,2))];
            else
                data=X(1+block_nsamps*(i-1):(block_nsamps)*i,:);
            end 
    
            % Check if modification necessary
            [mod_code, c]=d.modcheck.fhandle(c); 
        
            % Save upcoming data
            x=data.*ramp_off;
        
            % Modify main data stream
            [X, m]=d.modifier.fhandle(X, mod_code, m); 
        
            % Grab data from modified signal
            if i==nblocks
                % Load with the remainder of X, then pad zeros.         
                data=[X(1+block_nsamps*(i-1):end, :); zeros(block_nsamps - size(X(1+block_nsamps*(i-1):end, :),1), size(X,2))];
            else
                data=X(1+block_nsamps*(i-1):(block_nsamps)*i,:);
            end % if 
        
            % Ramp new stream up, mix with old stream. 
            %   The mixed signal is what's played back. 
    
            % XXX SHOULD THIS BE MIXED DIFFERENTLY FOR THE FIRST DATA BLOCK XXX ???
            data=data.*ramp_on + x; 
    
            % First time through, we need to start playback
            if i==1
                % Start audio playback, but do not advance until the device has really
                % started. Should help compensate for intialization time. 
        
                % Fill buffer with zeros
                PsychPortAudio('FillBuffer', phand, zeros(buffer_nsamps,size(data,2))'); 
        
                % Infinite repetitions
                %   Don't wait for it to start, just start moving along
                PsychPortAudio('Start', phand, 0, [], 0);
        
            end % if i==1
    
            % Now, loop until we're half way through the samples in this particular
            % buffer block
            pstatus=PsychPortAudio('GetStatus', phand);
    
            % Load data into playback buffer
            %   CWB tried specifying the start location (last parameter), but he
            %   encountered countless buffer underrun errors. Replacing the start
            %   location with [] forces the data to be "appended" to the end of the
            %   buffer. For whatever reason, this is far more robust and CWB
            %   encountered 0 buffer underrun errors. 
            PsychPortAudio('FillBuffer', phand, data', 1, []);    
            toc
    
            % Wait for previous section to finish before rewriting the audio 
            while pstatus.ElapsedOutSamples < block_nsamps * (i-1), pstatus=PsychPortAudio('GetStatus', phand); end
    
            pstatus=PsychPortAudio('GetStatus', phand);
            % Each time we're half way through a block, start rewriting the buffer
            while mod(pstatus.ElapsedOutSamples, buffer_nsamps) - startofblock < buffer_nsamps/4 % start updating sooner.  
                pstatus=PsychPortAudio('GetStatus', phand); 
            end % while
    
        end % for i=1:nblocks
    case {'byseries'}
        
        % 'byseries' was initially intended to administer the HINT. 
        
        % Sound playback
        portaudio_playrec([], pstruct, X, FS, 'fsx', FS);
        
        % Call modcheck        
        [mod_code, c]=d.modcheck.fhandle(c); 
        
        % Modify all time series        
        [X, m]=d.modifier.fhandle(X, mod_code, m); 
        
    otherwise
        error(['Unknown adaptive mode (' d.adaptive_mode '). See ''''adaptive_mode''''.']); 
end % switch d.adaptive_mode

% Clumsy close
%   Needs to be smarter to guarantee that sound playback has stopped. See
%   development notes above. 
PsychPortAudio('Close')